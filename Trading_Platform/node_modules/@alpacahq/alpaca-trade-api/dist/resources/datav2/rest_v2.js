"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLatestCryptoXBBO = exports.getLatestCryptoQuote = exports.getLatestCryptoTrade = exports.getCryptoBars = exports.getCryptoQuotes = exports.getCryptoTrades = exports.getSnapshots = exports.getSnapshot = exports.getLatestBars = exports.getLatestBar = exports.getLatestQuotes = exports.getLatestQuote = exports.getLatestTrades = exports.getLatestTrade = exports.getMultiBarsAsync = exports.getMultiBars = exports.getBars = exports.getMultiQuotesAsync = exports.getMultiQuotes = exports.getQuotes = exports.getMultiTradesAsync = exports.getMultiTrades = exports.getTrades = exports.getMultiDataV2 = exports.getDataV2 = exports.dataV2HttpRequest = exports.TYPE = exports.Adjustment = void 0;
var axios_1 = __importDefault(require("axios"));
var entityv2_1 = require("./entityv2");
// Number of data points to return.
var V2_MAX_LIMIT = 10000;
var Adjustment;
(function (Adjustment) {
    Adjustment["RAW"] = "raw";
    Adjustment["DIVIDEND"] = "dividend";
    Adjustment["SPLIT"] = "split";
    Adjustment["BOTH"] = "both";
})(Adjustment = exports.Adjustment || (exports.Adjustment = {}));
var TYPE;
(function (TYPE) {
    TYPE["TRADES"] = "trades";
    TYPE["QUOTES"] = "quotes";
    TYPE["BARS"] = "bars";
})(TYPE = exports.TYPE || (exports.TYPE = {}));
function dataV2HttpRequest(url, queryParams, config) {
    var dataBaseUrl = config.dataBaseUrl, keyId = config.keyId, secretKey = config.secretKey, oauth = config.oauth;
    var headers = {
        "Content-Type": "application/json",
        "Accept-Encoding": "gzip",
    };
    if (oauth == "") {
        headers["APCA-API-KEY-ID"] = keyId;
        headers["APCA-API-SECRET-KEY"] = secretKey;
    }
    else {
        headers["Authorization"] = "Bearer " + oauth;
    }
    var resp = axios_1.default
        .get("" + dataBaseUrl + url, {
        params: queryParams,
        headers: headers,
    })
        .catch(function (err) {
        throw new Error(err.message);
    });
    return resp;
}
exports.dataV2HttpRequest = dataV2HttpRequest;
function getDataV2(endpoint, path, options, config) {
    return __asyncGenerator(this, arguments, function getDataV2_1() {
        var pageToken, totalItems, limit, actualLimit, resp, items, _i, items_1, item;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    pageToken = null;
                    totalItems = 0;
                    limit = options.limit;
                    _a.label = 1;
                case 1:
                    if (!true) return [3 /*break*/, 8];
                    actualLimit = null;
                    if (limit) {
                        actualLimit = Math.min(limit - totalItems, V2_MAX_LIMIT);
                        if (actualLimit < 1) {
                            return [3 /*break*/, 8];
                        }
                    }
                    Object.assign(options, {
                        limit: actualLimit,
                        page_token: pageToken,
                    });
                    return [4 /*yield*/, __await(dataV2HttpRequest("" + path, options, config))];
                case 2:
                    resp = _a.sent();
                    items = resp.data[endpoint];
                    _i = 0, items_1 = items;
                    _a.label = 3;
                case 3:
                    if (!(_i < items_1.length)) return [3 /*break*/, 7];
                    item = items_1[_i];
                    return [4 /*yield*/, __await(item)];
                case 4: return [4 /*yield*/, _a.sent()];
                case 5:
                    _a.sent();
                    _a.label = 6;
                case 6:
                    _i++;
                    return [3 /*break*/, 3];
                case 7:
                    totalItems += items.length;
                    pageToken = resp.data.next_page_token;
                    if (!pageToken) {
                        return [3 /*break*/, 8];
                    }
                    return [3 /*break*/, 1];
                case 8: return [2 /*return*/];
            }
        });
    });
}
exports.getDataV2 = getDataV2;
function getMultiDataV2(symbols, endpoint, options, config) {
    return __asyncGenerator(this, arguments, function getMultiDataV2_1() {
        var pageToken, params, resp, items, _a, _b, _i, symbol, _c, _d, data;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    pageToken = null;
                    _e.label = 1;
                case 1:
                    if (!true) return [3 /*break*/, 10];
                    params = __assign(__assign({}, options), { symbols: symbols.join(","), limit: options.page_limit, page_token: pageToken });
                    return [4 /*yield*/, __await(dataV2HttpRequest("/v2/stocks/" + endpoint, params, config))];
                case 2:
                    resp = _e.sent();
                    items = resp.data[endpoint];
                    _a = [];
                    for (_b in items)
                        _a.push(_b);
                    _i = 0;
                    _e.label = 3;
                case 3:
                    if (!(_i < _a.length)) return [3 /*break*/, 9];
                    symbol = _a[_i];
                    _c = 0, _d = items[symbol];
                    _e.label = 4;
                case 4:
                    if (!(_c < _d.length)) return [3 /*break*/, 8];
                    data = _d[_c];
                    return [4 /*yield*/, __await({ symbol: symbol, data: data })];
                case 5: return [4 /*yield*/, _e.sent()];
                case 6:
                    _e.sent();
                    _e.label = 7;
                case 7:
                    _c++;
                    return [3 /*break*/, 4];
                case 8:
                    _i++;
                    return [3 /*break*/, 3];
                case 9:
                    pageToken = resp.data.next_page_token;
                    if (!pageToken) {
                        return [3 /*break*/, 10];
                    }
                    return [3 /*break*/, 1];
                case 10: return [2 /*return*/];
            }
        });
    });
}
exports.getMultiDataV2 = getMultiDataV2;
function getTrades(symbol, options, config) {
    return __asyncGenerator(this, arguments, function getTrades_1() {
        var trades, trades_1, trades_1_1, trade, e_1_1;
        var e_1, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    trades = getDataV2(TYPE.TRADES, "/v2/stocks/" + symbol + "/" + TYPE.TRADES, options, config);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 8, 9, 14]);
                    trades_1 = __asyncValues(trades);
                    _b.label = 2;
                case 2: return [4 /*yield*/, __await(trades_1.next())];
                case 3:
                    if (!(trades_1_1 = _b.sent(), !trades_1_1.done)) return [3 /*break*/, 7];
                    trade = trades_1_1.value;
                    return [4 /*yield*/, __await((0, entityv2_1.AlpacaTradeV2)(trade))];
                case 4: return [4 /*yield*/, _b.sent()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 14];
                case 8:
                    e_1_1 = _b.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 14];
                case 9:
                    _b.trys.push([9, , 12, 13]);
                    if (!(trades_1_1 && !trades_1_1.done && (_a = trades_1.return))) return [3 /*break*/, 11];
                    return [4 /*yield*/, __await(_a.call(trades_1))];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [3 /*break*/, 13];
                case 12:
                    if (e_1) throw e_1.error;
                    return [7 /*endfinally*/];
                case 13: return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    });
}
exports.getTrades = getTrades;
function getMultiTrades(symbols, options, config) {
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function () {
        var multiTrades, trades, multiTrades_1, multiTrades_1_1, t, items, e_2_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    multiTrades = getMultiTradesAsync(symbols, options, config);
                    trades = new Map();
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, 7, 12]);
                    multiTrades_1 = __asyncValues(multiTrades);
                    _b.label = 2;
                case 2: return [4 /*yield*/, multiTrades_1.next()];
                case 3:
                    if (!(multiTrades_1_1 = _b.sent(), !multiTrades_1_1.done)) return [3 /*break*/, 5];
                    t = multiTrades_1_1.value;
                    items = trades.get(t.Symbol) || new Array();
                    trades.set(t.Symbol, __spreadArray(__spreadArray([], items, true), [t], false));
                    _b.label = 4;
                case 4: return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 12];
                case 6:
                    e_2_1 = _b.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 12];
                case 7:
                    _b.trys.push([7, , 10, 11]);
                    if (!(multiTrades_1_1 && !multiTrades_1_1.done && (_a = multiTrades_1.return))) return [3 /*break*/, 9];
                    return [4 /*yield*/, _a.call(multiTrades_1)];
                case 8:
                    _b.sent();
                    _b.label = 9;
                case 9: return [3 /*break*/, 11];
                case 10:
                    if (e_2) throw e_2.error;
                    return [7 /*endfinally*/];
                case 11: return [7 /*endfinally*/];
                case 12: return [2 /*return*/, trades];
            }
        });
    });
}
exports.getMultiTrades = getMultiTrades;
function getMultiTradesAsync(symbols, options, config) {
    return __asyncGenerator(this, arguments, function getMultiTradesAsync_1() {
        var multiTrades, multiTrades_2, multiTrades_2_1, t, e_3_1;
        var e_3, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    multiTrades = getMultiDataV2(symbols, TYPE.TRADES, options, config);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 8, 9, 14]);
                    multiTrades_2 = __asyncValues(multiTrades);
                    _b.label = 2;
                case 2: return [4 /*yield*/, __await(multiTrades_2.next())];
                case 3:
                    if (!(multiTrades_2_1 = _b.sent(), !multiTrades_2_1.done)) return [3 /*break*/, 7];
                    t = multiTrades_2_1.value;
                    t.data = __assign(__assign({}, t.data), { S: t.symbol });
                    return [4 /*yield*/, __await((0, entityv2_1.AlpacaTradeV2)(t.data))];
                case 4: return [4 /*yield*/, _b.sent()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 14];
                case 8:
                    e_3_1 = _b.sent();
                    e_3 = { error: e_3_1 };
                    return [3 /*break*/, 14];
                case 9:
                    _b.trys.push([9, , 12, 13]);
                    if (!(multiTrades_2_1 && !multiTrades_2_1.done && (_a = multiTrades_2.return))) return [3 /*break*/, 11];
                    return [4 /*yield*/, __await(_a.call(multiTrades_2))];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [3 /*break*/, 13];
                case 12:
                    if (e_3) throw e_3.error;
                    return [7 /*endfinally*/];
                case 13: return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    });
}
exports.getMultiTradesAsync = getMultiTradesAsync;
function getQuotes(symbol, options, config) {
    return __asyncGenerator(this, arguments, function getQuotes_1() {
        var quotes, quotes_1, quotes_1_1, quote, e_4_1;
        var e_4, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    quotes = getDataV2(TYPE.QUOTES, "/v2/stocks/" + symbol + "/" + TYPE.QUOTES, options, config);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 8, 9, 14]);
                    quotes_1 = __asyncValues(quotes);
                    _b.label = 2;
                case 2: return [4 /*yield*/, __await(quotes_1.next())];
                case 3:
                    if (!(quotes_1_1 = _b.sent(), !quotes_1_1.done)) return [3 /*break*/, 7];
                    quote = quotes_1_1.value;
                    return [4 /*yield*/, __await((0, entityv2_1.AlpacaQuoteV2)(quote))];
                case 4: return [4 /*yield*/, _b.sent()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 14];
                case 8:
                    e_4_1 = _b.sent();
                    e_4 = { error: e_4_1 };
                    return [3 /*break*/, 14];
                case 9:
                    _b.trys.push([9, , 12, 13]);
                    if (!(quotes_1_1 && !quotes_1_1.done && (_a = quotes_1.return))) return [3 /*break*/, 11];
                    return [4 /*yield*/, __await(_a.call(quotes_1))];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [3 /*break*/, 13];
                case 12:
                    if (e_4) throw e_4.error;
                    return [7 /*endfinally*/];
                case 13: return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    });
}
exports.getQuotes = getQuotes;
function getMultiQuotes(symbols, options, config) {
    var e_5, _a;
    return __awaiter(this, void 0, void 0, function () {
        var multiQuotes, quotes, multiQuotes_1, multiQuotes_1_1, q, items, e_5_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    multiQuotes = getMultiQuotesAsync(symbols, options, config);
                    quotes = new Map();
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, 7, 12]);
                    multiQuotes_1 = __asyncValues(multiQuotes);
                    _b.label = 2;
                case 2: return [4 /*yield*/, multiQuotes_1.next()];
                case 3:
                    if (!(multiQuotes_1_1 = _b.sent(), !multiQuotes_1_1.done)) return [3 /*break*/, 5];
                    q = multiQuotes_1_1.value;
                    items = quotes.get(q.Symbol) || new Array();
                    quotes.set(q.Symbol, __spreadArray(__spreadArray([], items, true), [q], false));
                    _b.label = 4;
                case 4: return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 12];
                case 6:
                    e_5_1 = _b.sent();
                    e_5 = { error: e_5_1 };
                    return [3 /*break*/, 12];
                case 7:
                    _b.trys.push([7, , 10, 11]);
                    if (!(multiQuotes_1_1 && !multiQuotes_1_1.done && (_a = multiQuotes_1.return))) return [3 /*break*/, 9];
                    return [4 /*yield*/, _a.call(multiQuotes_1)];
                case 8:
                    _b.sent();
                    _b.label = 9;
                case 9: return [3 /*break*/, 11];
                case 10:
                    if (e_5) throw e_5.error;
                    return [7 /*endfinally*/];
                case 11: return [7 /*endfinally*/];
                case 12: return [2 /*return*/, quotes];
            }
        });
    });
}
exports.getMultiQuotes = getMultiQuotes;
function getMultiQuotesAsync(symbols, options, config) {
    return __asyncGenerator(this, arguments, function getMultiQuotesAsync_1() {
        var multiQuotes, multiQuotes_2, multiQuotes_2_1, q, e_6_1;
        var e_6, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    multiQuotes = getMultiDataV2(symbols, TYPE.QUOTES, options, config);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 8, 9, 14]);
                    multiQuotes_2 = __asyncValues(multiQuotes);
                    _b.label = 2;
                case 2: return [4 /*yield*/, __await(multiQuotes_2.next())];
                case 3:
                    if (!(multiQuotes_2_1 = _b.sent(), !multiQuotes_2_1.done)) return [3 /*break*/, 7];
                    q = multiQuotes_2_1.value;
                    q.data = __assign(__assign({}, q.data), { S: q.symbol });
                    return [4 /*yield*/, __await((0, entityv2_1.AlpacaQuoteV2)(q.data))];
                case 4: return [4 /*yield*/, _b.sent()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 14];
                case 8:
                    e_6_1 = _b.sent();
                    e_6 = { error: e_6_1 };
                    return [3 /*break*/, 14];
                case 9:
                    _b.trys.push([9, , 12, 13]);
                    if (!(multiQuotes_2_1 && !multiQuotes_2_1.done && (_a = multiQuotes_2.return))) return [3 /*break*/, 11];
                    return [4 /*yield*/, __await(_a.call(multiQuotes_2))];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [3 /*break*/, 13];
                case 12:
                    if (e_6) throw e_6.error;
                    return [7 /*endfinally*/];
                case 13: return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    });
}
exports.getMultiQuotesAsync = getMultiQuotesAsync;
function getBars(symbol, options, config) {
    return __asyncGenerator(this, arguments, function getBars_1() {
        var bars, bars_1, bars_1_1, bar, e_7_1;
        var e_7, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    bars = getDataV2(TYPE.BARS, "/v2/stocks/" + symbol + "/" + TYPE.BARS, options, config);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 8, 9, 14]);
                    bars_1 = __asyncValues(bars);
                    _b.label = 2;
                case 2: return [4 /*yield*/, __await(bars_1.next())];
                case 3:
                    if (!(bars_1_1 = _b.sent(), !bars_1_1.done)) return [3 /*break*/, 7];
                    bar = bars_1_1.value;
                    return [4 /*yield*/, __await((0, entityv2_1.AlpacaBarV2)(bar))];
                case 4: return [4 /*yield*/, _b.sent()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 14];
                case 8:
                    e_7_1 = _b.sent();
                    e_7 = { error: e_7_1 };
                    return [3 /*break*/, 14];
                case 9:
                    _b.trys.push([9, , 12, 13]);
                    if (!(bars_1_1 && !bars_1_1.done && (_a = bars_1.return))) return [3 /*break*/, 11];
                    return [4 /*yield*/, __await(_a.call(bars_1))];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [3 /*break*/, 13];
                case 12:
                    if (e_7) throw e_7.error;
                    return [7 /*endfinally*/];
                case 13: return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    });
}
exports.getBars = getBars;
function getMultiBars(symbols, options, config) {
    var e_8, _a;
    return __awaiter(this, void 0, void 0, function () {
        var multiBars, bars, multiBars_1, multiBars_1_1, b, items, e_8_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    multiBars = getMultiBarsAsync(symbols, options, config);
                    bars = new Map();
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, 7, 12]);
                    multiBars_1 = __asyncValues(multiBars);
                    _b.label = 2;
                case 2: return [4 /*yield*/, multiBars_1.next()];
                case 3:
                    if (!(multiBars_1_1 = _b.sent(), !multiBars_1_1.done)) return [3 /*break*/, 5];
                    b = multiBars_1_1.value;
                    items = bars.get(b.Symbol) || new Array();
                    bars.set(b.Symbol, __spreadArray(__spreadArray([], items, true), [b], false));
                    _b.label = 4;
                case 4: return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 12];
                case 6:
                    e_8_1 = _b.sent();
                    e_8 = { error: e_8_1 };
                    return [3 /*break*/, 12];
                case 7:
                    _b.trys.push([7, , 10, 11]);
                    if (!(multiBars_1_1 && !multiBars_1_1.done && (_a = multiBars_1.return))) return [3 /*break*/, 9];
                    return [4 /*yield*/, _a.call(multiBars_1)];
                case 8:
                    _b.sent();
                    _b.label = 9;
                case 9: return [3 /*break*/, 11];
                case 10:
                    if (e_8) throw e_8.error;
                    return [7 /*endfinally*/];
                case 11: return [7 /*endfinally*/];
                case 12: return [2 /*return*/, bars];
            }
        });
    });
}
exports.getMultiBars = getMultiBars;
function getMultiBarsAsync(symbols, options, config) {
    return __asyncGenerator(this, arguments, function getMultiBarsAsync_1() {
        var multiBars, multiBars_2, multiBars_2_1, b, e_9_1;
        var e_9, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    multiBars = getMultiDataV2(symbols, TYPE.BARS, options, config);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 8, 9, 14]);
                    multiBars_2 = __asyncValues(multiBars);
                    _b.label = 2;
                case 2: return [4 /*yield*/, __await(multiBars_2.next())];
                case 3:
                    if (!(multiBars_2_1 = _b.sent(), !multiBars_2_1.done)) return [3 /*break*/, 7];
                    b = multiBars_2_1.value;
                    b.data = __assign(__assign({}, b.data), { S: b.symbol });
                    return [4 /*yield*/, __await((0, entityv2_1.AlpacaBarV2)(b.data))];
                case 4: return [4 /*yield*/, _b.sent()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 14];
                case 8:
                    e_9_1 = _b.sent();
                    e_9 = { error: e_9_1 };
                    return [3 /*break*/, 14];
                case 9:
                    _b.trys.push([9, , 12, 13]);
                    if (!(multiBars_2_1 && !multiBars_2_1.done && (_a = multiBars_2.return))) return [3 /*break*/, 11];
                    return [4 /*yield*/, __await(_a.call(multiBars_2))];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [3 /*break*/, 13];
                case 12:
                    if (e_9) throw e_9.error;
                    return [7 /*endfinally*/];
                case 13: return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    });
}
exports.getMultiBarsAsync = getMultiBarsAsync;
function getLatestTrade(symbol, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v2/stocks/" + symbol + "/trades/latest", {}, config)];
                case 1:
                    resp = _a.sent();
                    return [2 /*return*/, (0, entityv2_1.AlpacaTradeV2)(resp.data.trade)];
            }
        });
    });
}
exports.getLatestTrade = getLatestTrade;
function getLatestTrades(symbols, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp, multiLatestTrades, multiLatestTradesResp, symbol;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v2/stocks/" + TYPE.TRADES + "/latest", { symbols: symbols.join(",") }, config)];
                case 1:
                    resp = _a.sent();
                    multiLatestTrades = resp.data.trades;
                    multiLatestTradesResp = new Map();
                    for (symbol in multiLatestTrades) {
                        multiLatestTradesResp.set(symbol, (0, entityv2_1.AlpacaTradeV2)(__assign({ S: symbol }, multiLatestTrades[symbol])));
                    }
                    return [2 /*return*/, multiLatestTradesResp];
            }
        });
    });
}
exports.getLatestTrades = getLatestTrades;
function getLatestQuote(symbol, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v2/stocks/" + symbol + "/quotes/latest", {}, config)];
                case 1:
                    resp = _a.sent();
                    return [2 /*return*/, (0, entityv2_1.AlpacaQuoteV2)(resp.data.quote)];
            }
        });
    });
}
exports.getLatestQuote = getLatestQuote;
function getLatestQuotes(symbols, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp, multiLatestQuotes, multiLatestQuotesResp, symbol;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v2/stocks/" + TYPE.QUOTES + "/latest", { symbols: symbols.join(",") }, config)];
                case 1:
                    resp = _a.sent();
                    multiLatestQuotes = resp.data.quotes;
                    multiLatestQuotesResp = new Map();
                    for (symbol in multiLatestQuotes) {
                        multiLatestQuotesResp.set(symbol, (0, entityv2_1.AlpacaQuoteV2)(__assign({ S: symbol }, multiLatestQuotes[symbol])));
                    }
                    return [2 /*return*/, multiLatestQuotesResp];
            }
        });
    });
}
exports.getLatestQuotes = getLatestQuotes;
function getLatestBar(symbol, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v2/stocks/" + symbol + "/bars/latest", {}, config)];
                case 1:
                    resp = _a.sent();
                    return [2 /*return*/, (0, entityv2_1.AlpacaBarV2)(resp.data.bar)];
            }
        });
    });
}
exports.getLatestBar = getLatestBar;
function getLatestBars(symbols, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp, multiLatestBars, multiLatestBarsResp, symbol;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v2/stocks/" + TYPE.BARS + "/latest", { symbols: symbols.join(",") }, config)];
                case 1:
                    resp = _a.sent();
                    multiLatestBars = resp.data.bars;
                    multiLatestBarsResp = new Map();
                    for (symbol in multiLatestBars) {
                        multiLatestBarsResp.set(symbol, (0, entityv2_1.AlpacaBarV2)(__assign({ S: symbol }, multiLatestBars[symbol])));
                    }
                    return [2 /*return*/, multiLatestBarsResp];
            }
        });
    });
}
exports.getLatestBars = getLatestBars;
function getSnapshot(symbol, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v2/stocks/" + symbol + "/snapshot", {}, config)];
                case 1:
                    resp = _a.sent();
                    return [2 /*return*/, (0, entityv2_1.AlpacaSnaphotV2)(resp.data)];
            }
        });
    });
}
exports.getSnapshot = getSnapshot;
function getSnapshots(symbols, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v2/stocks/snapshots?symbols=" + symbols.join(","), {}, config)];
                case 1:
                    resp = _a.sent();
                    result = Object.entries(resp.data).map(function (_a) {
                        var key = _a[0], val = _a[1];
                        return (0, entityv2_1.AlpacaSnaphotV2)(__assign({ symbol: key }, val));
                    });
                    return [2 /*return*/, result];
            }
        });
    });
}
exports.getSnapshots = getSnapshots;
function getCryptoTrades(symbol, options, config) {
    return __asyncGenerator(this, arguments, function getCryptoTrades_1() {
        var cryptoTrades, cryptoTrades_1, cryptoTrades_1_1, t, e_10_1;
        var e_10, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    cryptoTrades = getDataV2(TYPE.TRADES, "/v1beta1/crypto/" + symbol + "/trades", options, config);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 8, 9, 14]);
                    cryptoTrades_1 = __asyncValues(cryptoTrades);
                    _b.label = 2;
                case 2: return [4 /*yield*/, __await(cryptoTrades_1.next())];
                case 3:
                    if (!(cryptoTrades_1_1 = _b.sent(), !cryptoTrades_1_1.done)) return [3 /*break*/, 7];
                    t = cryptoTrades_1_1.value;
                    return [4 /*yield*/, __await((0, entityv2_1.AlpacaCryptoTrade)(__assign({ S: symbol }, t)))];
                case 4: return [4 /*yield*/, _b.sent()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 14];
                case 8:
                    e_10_1 = _b.sent();
                    e_10 = { error: e_10_1 };
                    return [3 /*break*/, 14];
                case 9:
                    _b.trys.push([9, , 12, 13]);
                    if (!(cryptoTrades_1_1 && !cryptoTrades_1_1.done && (_a = cryptoTrades_1.return))) return [3 /*break*/, 11];
                    return [4 /*yield*/, __await(_a.call(cryptoTrades_1))];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [3 /*break*/, 13];
                case 12:
                    if (e_10) throw e_10.error;
                    return [7 /*endfinally*/];
                case 13: return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    });
}
exports.getCryptoTrades = getCryptoTrades;
function getCryptoQuotes(symbol, options, config) {
    return __asyncGenerator(this, arguments, function getCryptoQuotes_1() {
        var cryptoQuotes, cryptoQuotes_1, cryptoQuotes_1_1, q, e_11_1;
        var e_11, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    cryptoQuotes = getDataV2(TYPE.QUOTES, "/v1beta1/crypto/" + symbol + "/quotes", options, config);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 8, 9, 14]);
                    cryptoQuotes_1 = __asyncValues(cryptoQuotes);
                    _b.label = 2;
                case 2: return [4 /*yield*/, __await(cryptoQuotes_1.next())];
                case 3:
                    if (!(cryptoQuotes_1_1 = _b.sent(), !cryptoQuotes_1_1.done)) return [3 /*break*/, 7];
                    q = cryptoQuotes_1_1.value;
                    return [4 /*yield*/, __await((0, entityv2_1.AlpacaCryptoQuote)(__assign({ S: symbol }, q)))];
                case 4: return [4 /*yield*/, _b.sent()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 14];
                case 8:
                    e_11_1 = _b.sent();
                    e_11 = { error: e_11_1 };
                    return [3 /*break*/, 14];
                case 9:
                    _b.trys.push([9, , 12, 13]);
                    if (!(cryptoQuotes_1_1 && !cryptoQuotes_1_1.done && (_a = cryptoQuotes_1.return))) return [3 /*break*/, 11];
                    return [4 /*yield*/, __await(_a.call(cryptoQuotes_1))];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [3 /*break*/, 13];
                case 12:
                    if (e_11) throw e_11.error;
                    return [7 /*endfinally*/];
                case 13: return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    });
}
exports.getCryptoQuotes = getCryptoQuotes;
function getCryptoBars(symbol, options, config) {
    return __asyncGenerator(this, arguments, function getCryptoBars_1() {
        var cryptoBars, cryptoBars_1, cryptoBars_1_1, b, e_12_1;
        var e_12, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    cryptoBars = getDataV2(TYPE.BARS, "/v1beta1/crypto/" + symbol + "/bars", options, config);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 8, 9, 14]);
                    cryptoBars_1 = __asyncValues(cryptoBars);
                    _b.label = 2;
                case 2: return [4 /*yield*/, __await(cryptoBars_1.next())];
                case 3:
                    if (!(cryptoBars_1_1 = _b.sent(), !cryptoBars_1_1.done)) return [3 /*break*/, 7];
                    b = cryptoBars_1_1.value;
                    return [4 /*yield*/, __await((0, entityv2_1.AlpacaCryptoBar)(__assign({ S: symbol }, b)))];
                case 4: return [4 /*yield*/, _b.sent()];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6: return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 14];
                case 8:
                    e_12_1 = _b.sent();
                    e_12 = { error: e_12_1 };
                    return [3 /*break*/, 14];
                case 9:
                    _b.trys.push([9, , 12, 13]);
                    if (!(cryptoBars_1_1 && !cryptoBars_1_1.done && (_a = cryptoBars_1.return))) return [3 /*break*/, 11];
                    return [4 /*yield*/, __await(_a.call(cryptoBars_1))];
                case 10:
                    _b.sent();
                    _b.label = 11;
                case 11: return [3 /*break*/, 13];
                case 12:
                    if (e_12) throw e_12.error;
                    return [7 /*endfinally*/];
                case 13: return [7 /*endfinally*/];
                case 14: return [2 /*return*/];
            }
        });
    });
}
exports.getCryptoBars = getCryptoBars;
function getLatestCryptoTrade(symbol, options, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v1beta1/crypto/" + symbol + "/trades/latest", options, config)];
                case 1:
                    resp = _a.sent();
                    return [2 /*return*/, (0, entityv2_1.AlpacaCryptoTrade)(__assign({ S: resp.data.symbol }, resp.data.trade))];
            }
        });
    });
}
exports.getLatestCryptoTrade = getLatestCryptoTrade;
function getLatestCryptoQuote(symbol, options, config) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, dataV2HttpRequest("/v1beta1/crypto/" + symbol + "/quotes/latest", options, config)];
                case 1:
                    resp = _a.sent();
                    return [2 /*return*/, (0, entityv2_1.AlpacaCryptoQuote)(__assign({ S: resp.data.symbol }, resp.data.quote))];
            }
        });
    });
}
exports.getLatestCryptoQuote = getLatestCryptoQuote;
function getLatestCryptoXBBO(symbol, options, config) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        var params, resp;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    params = { exchanges: (_a = options.exchanges) === null || _a === void 0 ? void 0 : _a.join(",") };
                    return [4 /*yield*/, dataV2HttpRequest("/v1beta1/crypto/" + symbol + "/xbbo/latest", params, config)];
                case 1:
                    resp = _b.sent();
                    return [2 /*return*/, (0, entityv2_1.AlpacaCryptoXBBO)(__assign({ S: resp.data.symbol }, resp.data.xbbo))];
            }
        });
    });
}
exports.getLatestCryptoXBBO = getLatestCryptoXBBO;
