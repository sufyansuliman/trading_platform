"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlpacaWebsocket = exports.ERROR = exports.CONN_ERROR = exports.EVENT = exports.STATE = void 0;
var events_1 = __importDefault(require("events"));
var ws_1 = __importDefault(require("ws"));
var msgpack5_1 = __importDefault(require("msgpack5"));
// Connection states. Each of these will also emit EVENT.STATE_CHANGE
var STATE;
(function (STATE) {
    STATE["AUTHENTICATING"] = "authenticating";
    STATE["AUTHENTICATED"] = "authenticated";
    STATE["CONNECTED"] = "connected";
    STATE["CONNECTING"] = "connecting";
    STATE["DISCONNECTED"] = "disconnected";
    STATE["WAITING_TO_CONNECT"] = "waiting to connect";
    STATE["WAITING_TO_RECONNECT"] = "waiting to reconnect";
})(STATE = exports.STATE || (exports.STATE = {}));
// Stock client events
var EVENT;
(function (EVENT) {
    EVENT["CLIENT_ERROR"] = "client_error";
    EVENT["STATE_CHANGE"] = "state_change";
    EVENT["AUTHORIZED"] = "authorized";
    EVENT["UNAUTHORIZED"] = "unauthorized";
    EVENT["TRADES"] = "stock_trades";
    EVENT["QUOTES"] = "stock_quotes";
    EVENT["BARS"] = "stock_bars";
    EVENT["DAILY_BARS"] = "stock_daily_bars";
    EVENT["TRADING_STATUSES"] = "trading_statuses";
    EVENT["LULDS"] = "lulds";
})(EVENT = exports.EVENT || (exports.EVENT = {}));
// Connection errors by code
exports.CONN_ERROR = new Map([
    [400, "invalid syntax"],
    [401, "not authenticated"],
    [402, "auth failed"],
    [403, "already authenticated"],
    [404, "auth timeout"],
    [405, "symbol limit exceeded"],
    [406, "connection limit exceeded"],
    [407, "slow client"],
    [408, "v2 not enabled"],
    [409, "insufficient subscription"],
    [500, "internal error"],
]);
// Connection errors without code
var ERROR;
(function (ERROR) {
    ERROR["MISSING_SECERT_KEY"] = "missing secret key";
    ERROR["MISSING_API_KEY"] = "missing api key";
    ERROR["UNEXPECTED_MESSAGE"] = "unexpected message";
})(ERROR = exports.ERROR || (exports.ERROR = {}));
var AlpacaWebsocket = /** @class */ (function (_super) {
    __extends(AlpacaWebsocket, _super);
    function AlpacaWebsocket(options) {
        var _this = _super.call(this) || this;
        _this.msgpack = (0, msgpack5_1.default)();
        _this.session = {
            apiKey: options.apiKey,
            secretKey: options.secretKey,
            subscriptions: options.subscriptions,
            reconnect: true,
            verbose: options.verbose,
            backoff: true,
            reconnectTimeout: 0,
            maxReconnectTimeout: 30,
            backoffIncrement: 0.5,
            url: options.url,
            currentState: STATE.WAITING_TO_CONNECT,
        };
        if (_this.session.apiKey.length === 0) {
            throw new Error(ERROR.MISSING_API_KEY);
        }
        if (_this.session.secretKey.length === 0) {
            throw new Error(ERROR.MISSING_SECERT_KEY);
        }
        // Register internal event handlers
        // Log and emit every state change
        Object.values(STATE).forEach(function (s) {
            _this.on(s, function () {
                _this.emit(EVENT.STATE_CHANGE, s);
            });
        });
        return _this;
    }
    AlpacaWebsocket.prototype.connect = function () {
        var _this = this;
        this.emit(STATE.CONNECTING);
        this.session.currentState = STATE.CONNECTING;
        this.conn = new ws_1.default(this.session.url, {
            perMessageDeflate: {
                serverNoContextTakeover: false,
                clientNoContextTakeover: false,
            },
            headers: {
                "Content-Type": "application/msgpack",
            },
        });
        this.conn.binaryType = "nodebuffer";
        this.conn.once("open", function () { return _this.authenticate(); });
        this.conn.on("message", function (data) {
            _this.handleMessage(_this.msgpack.decode(data));
        });
        this.conn.on("error", function (err) {
            _this.emit(EVENT.CLIENT_ERROR, err.message);
            _this.disconnect();
        });
        this.conn.once("close", function () {
            if (_this.session.reconnect) {
                _this.reconnecting();
            }
        });
    };
    AlpacaWebsocket.prototype.onConnect = function (fn) {
        var _this = this;
        this.on(STATE.AUTHENTICATED, function () {
            fn();
            //if reconnected the user should subcribe to its symbols again
            _this.subscribeAll();
        });
    };
    AlpacaWebsocket.prototype.reconnecting = function () {
        var _this = this;
        var _a = this.session, backoff = _a.backoff, backoffIncrement = _a.backoffIncrement, maxReconnectTimeout = _a.maxReconnectTimeout;
        var reconnectTimeout = this.session.reconnectTimeout;
        if (backoff &&
            reconnectTimeout &&
            backoffIncrement &&
            maxReconnectTimeout) {
            setTimeout(function () {
                reconnectTimeout += backoffIncrement;
                if (reconnectTimeout > maxReconnectTimeout) {
                    reconnectTimeout = maxReconnectTimeout;
                }
                _this.connect();
            }, reconnectTimeout * 1000);
            this.emit(STATE.WAITING_TO_RECONNECT, reconnectTimeout);
        }
    };
    AlpacaWebsocket.prototype.authenticate = function () {
        var authMsg = {
            action: "auth",
            key: this.session.apiKey,
            secret: this.session.secretKey,
        };
        this.conn.send(this.msgpack.encode(authMsg));
        this.emit(STATE.AUTHENTICATING);
        this.session.currentState = STATE.AUTHENTICATING;
    };
    AlpacaWebsocket.prototype.disconnect = function () {
        this.emit(STATE.DISCONNECTED);
        this.session.currentState = STATE.DISCONNECTED;
        this.conn.close();
        this.session.reconnect = false;
    };
    AlpacaWebsocket.prototype.onDisconnect = function (fn) {
        this.on(STATE.DISCONNECTED, function () { return fn(); });
    };
    AlpacaWebsocket.prototype.onError = function (fn) {
        this.on(EVENT.CLIENT_ERROR, function (err) { return fn(err); });
    };
    AlpacaWebsocket.prototype.onStateChange = function (fn) {
        this.on(EVENT.STATE_CHANGE, function (newState) { return fn(newState); });
    };
    AlpacaWebsocket.prototype.handleMessage = function (data) {
        var msgType = (data === null || data === void 0 ? void 0 : data.length) ? data[0].T : "";
        switch (msgType) {
            case "success":
                if (data[0].msg === "connected") {
                    this.emit(STATE.CONNECTED);
                    this.session.currentState = STATE.CONNECTED;
                }
                else if (data[0].msg === "authenticated") {
                    this.emit(STATE.AUTHENTICATED);
                    this.session.currentState = STATE.AUTHENTICATED;
                }
                break;
            case "subscription":
                this.updateSubscriptions(data[0]);
                break;
            case "error":
                this.emit(EVENT.CLIENT_ERROR, exports.CONN_ERROR.get(data[0].code));
                break;
            default:
                this.dataHandler(data);
        }
    };
    AlpacaWebsocket.prototype.log = function (msg) {
        if (this.session.verbose) {
            // eslint-disable-next-line no-console
            console.log(msg);
        }
    };
    AlpacaWebsocket.prototype.getSubscriptions = function () {
        return this.session.subscriptions;
    };
    return AlpacaWebsocket;
}(events_1.default.EventEmitter));
exports.AlpacaWebsocket = AlpacaWebsocket;
