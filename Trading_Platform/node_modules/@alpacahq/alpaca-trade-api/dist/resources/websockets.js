"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events = require("events");
var WebSocket = require("ws");
var polygon = require('./polygonWebsocket');
var entity = require('./entity');
// Listeners
// A client can listen on any of the following events, states, or errors
// Connection states. Each of these will also emit EVENT.STATE_CHANGE
var STATE;
(function (STATE) {
    STATE.AUTHENTICATING = "authenticating";
    STATE.CONNECTED = "connected";
    STATE.CONNECTING = "connecting";
    STATE.DISCONNECTED = "disconnected";
    STATE.WAITING_TO_CONNECT = "waiting to connect";
    STATE.WAITING_TO_RECONNECT = "waiting to reconnect";
})(STATE = exports.STATE || (exports.STATE = {}));
// Client events
var EVENT;
(function (EVENT) {
    EVENT.CLIENT_ERROR = "client_error";
    EVENT.STATE_CHANGE = "state_change";
    EVENT.AUTHORIZED = "authorized";
    EVENT.UNAUTHORIZED = "unauthorized";
    EVENT.ORDER_UPDATE = "trade_updates";
    EVENT.ACCOUNT_UPDATE = "account_updates";
    EVENT.STOCK_TRADES = "stock_trades";
    EVENT.STOCK_QUOTES = "stock_quotes";
    EVENT.STOCK_AGG_SEC = "stock_agg_sec";
    EVENT.STOCK_AGG_MIN = "stock_agg_min";
})(EVENT = exports.EVENT || (exports.EVENT = {}));
// Connection errors Each of these will also emit EVENT.ERROR
var ERROR;
(function (ERROR) {
    ERROR.BAD_KEY_OR_SECRET = "bad key id or secret";
    ERROR.CONNECTION_REFUSED = "connection refused";
    ERROR.MISSING_API_KEY = "missing api key";
    ERROR.MISSING_SECRET_KEY = "missing secret key";
    ERROR.UNKNOWN = "unknown error";
})(ERROR = exports.ERROR || (exports.ERROR = {}));
/**
 * AlpacaStreamClient manages a connection to Alpaca's websocket api
 */
var AlpacaStreamClient = /** @class */ (function (_super) {
    __extends(AlpacaStreamClient, _super);
    function AlpacaStreamClient(opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this) || this;
        _this.defaultOptions = {
            // A list of subscriptions to subscribe to on connection
            subscriptions: [],
            // Whether the library should reconnect automatically
            reconnect: true,
            // Reconnection backoff: if true, then the reconnection time will be initially
            // reconnectTimeout, then will double with each unsuccessful connection attempt.
            // It will not exceed maxReconnectTimeout
            backoff: true,
            // Initial reconnect timeout (seconds) a minimum of 1 will be used if backoff=false
            reconnectTimeout: 0,
            // The maximum amount of time between reconnect tries (applies to backoff)
            maxReconnectTimeout: 30,
            // The amount of time to increment the delay between each reconnect attempt
            backoffIncrement: 0.5,
            // If true, client outputs detailed log messages
            verbose: false,
            // If true we will use the polygon ws data source, otherwise we use
            // alpaca ws data source
            usePolygon: false,
        };
        // Set minimum reconnectTimeout of 1s if backoff=false
        if (!opts.backoff && opts.reconnectTimeout < 1) {
            opts.reconnectTimeout = 1;
        }
        // Merge supplied options with defaults
        _this.session = Object.assign(_this.defaultOptions, opts);
        _this.session.url = _this.session.url.replace(/^http/, "ws") + "/stream";
        if (_this.session.apiKey.length === 0 && _this.session.oauth.length === 0) {
            throw new Error(ERROR.MISSING_API_KEY);
        }
        if (_this.session.secretKey.length === 0 && _this.session.oauth.length === 0) {
            throw new Error(ERROR.MISSING_SECRET_KEY);
        }
        // Keep track of subscriptions in case we need to reconnect after the client
        // has called subscribe()
        _this.subscriptionState = {};
        _this.session.subscriptions.forEach(function (x) {
            _this.subscriptionState[x] = true;
        });
        _this.currentState = STATE.WAITING_TO_CONNECT;
        // Register internal event handlers
        // Log and emit every state change
        Object.keys(STATE).forEach(function (s) {
            _this.on(STATE[s], function () {
                _this.currentState = STATE[s];
                _this.log("info", "state change: " + STATE[s]);
                _this.emit(EVENT.STATE_CHANGE, STATE[s]);
            });
        });
        // Log and emit every error
        Object.keys(ERROR).forEach(function (e) {
            _this.on(ERROR[e], function () {
                _this.log("error", ERROR[e]);
                _this.emit(EVENT.CLIENT_ERROR, ERROR[e]);
            });
        });
        // Create Polygon event emitter for callback registration
        _this.polygon = new polygon.PolygonWebsocket(_this.session.apiKey, _this.session);
        return _this;
    }
    AlpacaStreamClient.prototype.connect = function () {
        var _this = this;
        // Reset reconnectDisabled since the user called connect() again
        this.reconnectDisabled = false;
        this.emit(STATE.CONNECTING);
        this.conn = new WebSocket(this.session.url);
        this.conn.once("open", function () {
            _this.authenticate();
        });
        this.conn.on("message", function (data) { return _this.handleMessage(data); });
        this.conn.once("error", function (err) {
            _this.emit(ERROR.CONNECTION_REFUSED);
        });
        this.conn.once("close", function () {
            _this.emit(STATE.DISCONNECTED);
            if (_this.session.reconnect && !_this.reconnectDisabled) {
                _this.reconnect();
            }
        });
    };
    AlpacaStreamClient.prototype._ensure_polygon = function (channels) {
        if (this.polygon.connectCalled) {
            if (channels) {
                this.polygon.subscribe(channels);
            }
            return;
        }
        this.polygon.connect(channels);
    };
    AlpacaStreamClient.prototype._unsubscribe_polygon = function (channels) {
        if (this.polygon.connectCalled) {
            if (channels) {
                this.polygon.unsubscribe(channels);
            }
        }
    };
    AlpacaStreamClient.prototype.subscribe = function (keys) {
        var _this = this;
        var wsChannels = [];
        var polygonChannels = [];
        keys.forEach(function (key) {
            var poly = ['Q.', 'T.', 'A.', 'AM.'];
            var found = poly.filter(function (channel) { return key.startsWith(channel); });
            if (found.length > 0) {
                polygonChannels.push(key);
            }
            else {
                wsChannels.push(key);
            }
        });
        if (wsChannels.length > 0) {
            var subMsg = {
                action: 'listen',
                data: {
                    streams: wsChannels
                }
            };
            this.send(JSON.stringify(subMsg));
        }
        if (polygonChannels.length > 0) {
            this._ensure_polygon(polygonChannels);
        }
        keys.forEach(function (x) {
            _this.subscriptionState[x] = true;
        });
    };
    AlpacaStreamClient.prototype.unsubscribe = function (keys) {
        var _this = this;
        // Currently, only Polygon channels can be unsubscribed from
        var polygonChannels = [];
        keys.forEach(function (key) {
            var poly = ['Q.', 'T.', 'A.', 'AM.'];
            var found = poly.filter(function (channel) { return key.startsWith(channel); });
            if (found.length > 0) {
                polygonChannels.push(key);
            }
        });
        if (polygonChannels.length > 0) {
            this._unsubscribe_polygon(polygonChannels);
        }
        keys.forEach(function (x) {
            _this.subscriptionState[x] = false;
        });
    };
    AlpacaStreamClient.prototype.subscriptions = function () {
        var _this = this;
        // if the user unsubscribes from certain equities, they will still be
        // under this.subscriptionState but with value "false", so we need to
        // filter them out
        return Object.keys(this.subscriptionState).filter(function (x) { return _this.subscriptionState[x]; });
    };
    AlpacaStreamClient.prototype.onConnect = function (fn) {
        this.on(STATE.CONNECTED, function () { return fn(); });
    };
    AlpacaStreamClient.prototype.onDisconnect = function (fn) {
        this.on(STATE.DISCONNECTED, function () { return fn(); });
    };
    AlpacaStreamClient.prototype.onStateChange = function (fn) {
        this.on(EVENT.STATE_CHANGE, function (newState) { return fn(newState); });
    };
    AlpacaStreamClient.prototype.onError = function (fn) {
        this.on(EVENT.CLIENT_ERROR, function (err) { return fn(err); });
    };
    AlpacaStreamClient.prototype.onOrderUpdate = function (fn) {
        this.on(EVENT.ORDER_UPDATE, function (orderUpdate) { return fn(orderUpdate); });
    };
    AlpacaStreamClient.prototype.onAccountUpdate = function (fn) {
        this.on(EVENT.ACCOUNT_UPDATE, function (accountUpdate) { return fn(accountUpdate); });
    };
    AlpacaStreamClient.prototype.onPolygonConnect = function (fn) {
        this.polygon.on(STATE.CONNECTED, function () { return fn(); });
    };
    AlpacaStreamClient.prototype.onPolygonDisconnect = function (fn) {
        this.polygon.on(STATE.DISCONNECTED, function () { return fn(); });
    };
    AlpacaStreamClient.prototype.onStockTrades = function (fn) {
        if (this.session.usePolygon) {
            this.polygon.on(EVENT.STOCK_TRADES, function (subject, data) { fn(subject, data); });
        }
        else {
            this.on(EVENT.STOCK_TRADES, function (subject, data) { fn(subject, data); });
        }
    };
    AlpacaStreamClient.prototype.onStockQuotes = function (fn) {
        if (this.session.usePolygon) {
            this.polygon.on(EVENT.STOCK_QUOTES, function (subject, data) { fn(subject, data); });
        }
        else {
            this.on(EVENT.STOCK_QUOTES, function (subject, data) { fn(subject, data); });
        }
    };
    AlpacaStreamClient.prototype.onStockAggSec = function (fn) {
        this.polygon.on(EVENT.STOCK_AGG_SEC, function (subject, data) { fn(subject, data); });
    };
    AlpacaStreamClient.prototype.onStockAggMin = function (fn) {
        if (this.session.usePolygon) {
            this.polygon.on(EVENT.STOCK_AGG_MIN, function (subject, data) { fn(subject, data); });
        }
        else {
            this.on(EVENT.STOCK_AGG_MIN, function (subject, data) { fn(subject, data); });
        }
    };
    AlpacaStreamClient.prototype.send = function (data) {
        this.conn.send(data);
    };
    AlpacaStreamClient.prototype.disconnect = function () {
        this.reconnectDisabled = true;
        this.conn.close();
        if (this.polygon) {
            this.polygon.close();
        }
    };
    AlpacaStreamClient.prototype.state = function () {
        return this.currentState;
    };
    AlpacaStreamClient.prototype.get = function (key) {
        return this.session[key];
    };
    AlpacaStreamClient.prototype.reconnect = function () {
        var _this = this;
        setTimeout(function () {
            if (_this.session.backoff) {
                _this.session.reconnectTimeout += _this.session.backoffIncrement;
                if (_this.session.reconnectTimeout > _this.session.maxReconnectTimeout) {
                    _this.session.reconnectTimeout = _this.session.maxReconnectTimeout;
                }
            }
            _this.connect();
        }, this.session.reconnectTimeout * 1000);
        this.emit(STATE.WAITING_TO_RECONNECT, this.session.reconnectTimeout);
    };
    AlpacaStreamClient.prototype.authenticate = function () {
        this.emit(STATE.AUTHENTICATING);
        var authMsg = {
            action: 'authenticate',
            data: {
                key_id: this.session.apiKey,
                secret_key: this.session.secretKey
            }
        };
        this.send(JSON.stringify(authMsg));
    };
    AlpacaStreamClient.prototype.handleMessage = function (data) {
        // Heartbeat
        var bytes = new Uint8Array(data);
        if (bytes.length === 1 && bytes[0] === 1) {
            return;
        }
        var message = JSON.parse(data);
        var subject = message.stream;
        if ('error' in message.data) {
            console.log(message.data.error);
        }
        switch (subject) {
            case "authorization":
                this.authResultHandler(message.data.status);
                break;
            case "listening":
                this.log("listening to the streams: " + message.data.streams);
                break;
            case "trade_updates":
                this.emit(EVENT.ORDER_UPDATE, message.data);
                break;
            case "account_updates":
                this.emit(EVENT.ACCOUNT_UPDATE, message.data);
                break;
            default:
                if (message.stream.startsWith('T.')) {
                    this.emit(EVENT.STOCK_TRADES, subject, entity.AlpacaTrade(message.data));
                }
                else if (message.stream.startsWith('Q.')) {
                    this.emit(EVENT.STOCK_QUOTES, subject, entity.AlpacaQuote(message.data));
                }
                else if (message.stream.startsWith('AM.')) {
                    this.emit(EVENT.STOCK_AGG_MIN, subject, entity.AggMinuteBar(message.data));
                }
                else {
                    this.emit(ERROR.PROTOBUF);
                }
        }
    };
    AlpacaStreamClient.prototype.authResultHandler = function (authResult) {
        switch (authResult) {
            case 'authorized':
                this.emit(STATE.CONNECTED);
                break;
            case 'unauthorized':
                this.emit(ERROR.BAD_KEY_OR_SECRET);
                this.disconnect();
                break;
            default:
                break;
        }
    };
    AlpacaStreamClient.prototype.log = function (level) {
        var msg = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            msg[_i - 1] = arguments[_i];
        }
        if (this.session.verbose) {
            console[level].apply(console, msg);
        }
    };
    return AlpacaStreamClient;
}(events.EventEmitter));
exports.AlpacaStreamClient = AlpacaStreamClient;
